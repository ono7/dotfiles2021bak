= functions =


== unpacking ==

{{{lua

> print(ConvertHexToRGB(“FFFFFF“))
1, 1, 1
> print(ConvertHexToRGB(“FFFFFF“), “SomeOtherArgument“) 1, SomeOtherArgument

}}}

Where did the other returns go? They were eaten by the following rule: When a
function call with multiple return values is the last argument to another
function, or the last argument in a multiple assignment expression, all of the
return values are passed or used. Otherwise, only the first return value is used
or assigned. You can see this behavior with the assignment operator in the
following example:

{{{lua

> a, b, c, d = ConvertHexToRGB(“FFFFFF“), “some“, “more“, “arguments“ > print(a, b, c, d)
1, some, more, arguments

}}}



When working with multiple re turn values,you can always wrap the function call in
parentheses to limit it to a single return value, as follows:

{{{lua

> print((ConvertHexToRGB("FFFFFF")))
1

}}}


=== select ===

If a function returns multiple values, it maybe useful to only select the one we
are interested in, such as in GetRaidRosterInfo() which may have many values
returned. To isolate a ret value, you can use select(2,GetRaidRosterInfo())

select() returns from the 2nd argument forward, but we can use select to throw
away the rest by wrapping the select in parenthesis

{{{lua
x = (select(2, GetRaidRosterInfo()))
}}}
